import importlib.resources
import re
from argparse import Namespace
from collections import defaultdict
from contextlib import ExitStack
from typing import Dict, List, Literal, Tuple

import sympy
from sympy.physics.quantum import TensorProduct

import radiomesh

OUTPUT_FILENAME = "_stokes_expr.py"

PREAMBLE = """
# This file is automatically generated.
# It should not be directly modified.

from numpy import conjugate as conj


"""

FnMapType = defaultdict[str, defaultdict[str, str]]

POLARISATION_TYPES = ["linear", "circular"]
P_GAIN_ARGUMENTS = ["gp00", "gp01", "gp10", "gp11"]
Q_GAIN_ARGUMENTS = ["gq00", "gq01", "gq10", "gq11"]
WEIGHT_ARGUMENTS = ["w00", "w01", "w10", "w11"]
VIS_ARGUMENTS = ["v00", "v01", "v10", "v11"]
WEIGHT_FN_ARGUMENTS = WEIGHT_ARGUMENTS + P_GAIN_ARGUMENTS + Q_GAIN_ARGUMENTS
VIS_FN_ARGUMENTS = VIS_ARGUMENTS + P_GAIN_ARGUMENTS + Q_GAIN_ARGUMENTS


def sympy_expressions(
  polarisations: str | Literal["linear", "circular"],
) -> Tuple[List[str], sympy.Expr, sympy.Expr, sympy.Expr, sympy.Expr]:
  """
  Returns
  -------
    A tuple of the form (schema, coherencies, weights) where
      1. schema is a list of stokes values
      2. coherencies is a sympy expression for generating stokes values
        from visibilities, weights and gains
      3. weights is a sympy expression for generating weights
        from gains and weights.
  """
  # set up symbolic expressions
  gp00, gp10, gp01, gp11 = sympy.symbols(" ".join(P_GAIN_ARGUMENTS), real=False)
  gq00, gq10, gq01, gq11 = sympy.symbols(" ".join(Q_GAIN_ARGUMENTS), real=False)
  w00, w01, w10, w11 = sympy.symbols(" ".join(WEIGHT_ARGUMENTS), real=True)
  v00, v10, v01, v11 = sympy.symbols(" ".join(VIS_ARGUMENTS), real=False)

  # Jones matrices
  Gp = sympy.Matrix([[gp00, gp01], [gp10, gp11]])
  Gq = sympy.Matrix([[gq00, gq01], [gq10, gq11]])

  # Mueller matrix (row major form)
  Mpq = TensorProduct(Gp, Gq.conjugate())
  Mpqinv = TensorProduct(Gp.inv(), Gq.conjugate().inv())

  # inverse noise covariance
  Sinv = sympy.Matrix([[w00, 0, 0, 0], [0, w01, 0, 0], [0, 0, w10, 0], [0, 0, 0, w11]])
  S = Sinv.inv()

  # visibilities
  Vpq = sympy.Matrix([[v00], [v01], [v10], [v11]])

  # Full Stokes to corr operator
  # Is this the only difference between linear and circular pol?
  # What about paralactic angle rotation?

  if polarisations == "linear":
    T = sympy.Matrix(
      [[1.0, 1.0, 0, 0], [0, 0, 1.0, 1.0j], [0, 0, 1.0, -1.0j], [1.0, -1.0, 0, 0]]
    )
  elif polarisations == "circular":
    T = sympy.Matrix(
      [[1.0, 0, 0, 1.0], [0, 1.0, 1.0j, 0], [0, 1.0, -1.0j, 0], [1.0, 0, 0, -1.0]]
    )
  else:
    raise ValueError(f"{polarisations} not in {POLARISATION_TYPES}")

  Tinv = T.inv()

  # Full Stokes weights
  W = T.H * Mpq.H * Sinv * Mpq * T
  Winv = Tinv * Mpqinv * S * Mpqinv.H * Tinv.H

  # Full Stokes coherencies
  schema = ["I", "Q", "U", "V"]
  C = Winv * (T.H * (Mpq.H * (Sinv * Vpq)))
  # Only keep diagonal of weights
  W = W.diagonal().T  # diagonal() returns row vector

  C = sympy.simplify(C)
  W = sympy.simplify(W)

  id_gains = {
    gp00: 1.0,
    gp01: 0.0,
    gp10: 0.0,
    gp11: 1.0,
    gq00: 1.0,
    gq01: 0.0,
    gq10: 0.0,
    gq11: 1.0,
  }

  C_no_gains = sympy.simplify(C.subs(id_gains))
  W_no_gains = sympy.simplify(W.subs(id_gains))

  return schema, C, W, C_no_gains, W_no_gains


def subs_sympy(expr: sympy.Expr) -> str:
  """Simple string substitution on a sympy expression

  1. "I" -> "1j"
  2. "1.0*" -> ""
  3. "conjugate" -> "conj"
  """
  expr = re.sub(r"\bI\b", "1j", str(expr))
  expr = re.sub(r"\b1.0\*", "", str(expr))
  return re.sub(r"\bconjugate\b", "conj", expr)


def generate_expression(args: Namespace):
  with ExitStack() as stack:
    expr_path = stack.enter_context(
      importlib.resources.path(radiomesh, OUTPUT_FILENAME)
    )
    f = stack.enter_context(open(expr_path, "w"))

    f.write(PREAMBLE)
    conv_fns: Dict[Tuple[str, str, str, str], str] = {}

    for pol_type in POLARISATION_TYPES:
      stokes_schema, coh_gains, wgt_gains, coh, wgt = sympy_expressions(pol_type)
      assert coh_gains.shape == coh.shape == (len(stokes_schema), 1)
      assert wgt_gains.shape == wgt.shape == (len(stokes_schema), 1)

      for stokes, coh_gains in zip(stokes_schema, coh_gains):
        fn_name = f"{pol_type.upper()}_VIS_GAINS_{stokes.upper()}"
        key = ("VIS", pol_type.upper(), "GAINS", stokes.upper())
        conv_fns[key] = fn_name
        f.write(f"def {fn_name}({', '.join(VIS_FN_ARGUMENTS)}):\n")
        f.write(f"  return {subs_sympy(coh_gains)}\n")
        f.write("\n")

      for stokes, wgt_gains in zip(stokes_schema, wgt_gains):
        fn_name = f"{pol_type.upper()}_WEIGHT_GAINS_{stokes.upper()}"
        key = ("WEIGHT", pol_type.upper(), "GAINS", stokes.upper())
        conv_fns[key] = fn_name
        f.write(f"def {fn_name}({', '.join(WEIGHT_FN_ARGUMENTS)}):\n")
        f.write(f"  return ({subs_sympy(wgt_gains)}).real\n")
        f.write("\n")

      for stokes, coh in zip(stokes_schema, coh):
        fn_name = f"{pol_type.upper()}_VIS_NOGAINS_{stokes.upper()}"
        key = ("VIS", pol_type.upper(), "NOGAINS", stokes.upper())
        conv_fns[key] = fn_name
        f.write(f"def {fn_name}({', '.join(VIS_ARGUMENTS)}):\n")
        f.write(f"  return {subs_sympy(coh)}\n")
        f.write("\n")

      for stokes, wgt in zip(stokes_schema, wgt):
        fn_name = f"{pol_type.upper()}_WEIGHT_NOGAINS_{stokes.upper()}"
        key = ("WEIGHT", pol_type.upper(), "NOGAINS", stokes.upper())
        conv_fns[key] = fn_name
        f.write(f"def {fn_name}({', '.join(WEIGHT_ARGUMENTS)}):\n")
        f.write(f"  return ({subs_sympy(wgt)}).real\n")
        f.write("\n")

    f.write("CONVERT_FNS = {\n")
    for key, fn_name in conv_fns.items():
      f.write(f"  {key}: {fn_name},\n")
    f.write("}\n")
    f.write("\n")
