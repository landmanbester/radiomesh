import importlib.resources
import re
from argparse import Namespace
from contextlib import ExitStack
from typing import Dict, List, Literal, Tuple

import sympy
from sympy.physics.quantum import TensorProduct

import radiomesh

OUTPUT_FILENAME = "_stokes_expr.py"

PREAMBLE = """
# This file is automatically generated
# via the `radiomesh gen-expr` command.
# It should not be directly modified.

from numpy import conjugate as conj


"""

POLARISATION_TYPES = ["linear", "circular"]
JONES_P_ARGUMENTS = ["jp00", "jp01", "jp10", "jp11"]
JONES_Q_ARGUMENTS = ["jq00", "jq01", "jq10", "jq11"]
WEIGHT_ARGUMENTS = ["w00", "w01", "w10", "w11"]
VIS_ARGUMENTS = ["v00", "v01", "v10", "v11"]
WEIGHT_FN_ARGUMENTS = WEIGHT_ARGUMENTS + JONES_P_ARGUMENTS + JONES_Q_ARGUMENTS
VIS_FN_ARGUMENTS = VIS_ARGUMENTS + JONES_P_ARGUMENTS + JONES_Q_ARGUMENTS


def sympy_expressions(
  polarisations: str | Literal["linear", "circular"],
) -> Tuple[List[str], sympy.Expr, sympy.Expr, sympy.Expr, sympy.Expr]:
  """
  Returns
  -------
    A tuple of the form (schema, coherencies, weights) where
      1. schema is a list of stokes values
      2. coherencies is a sympy expression for generating stokes values
        from visibilities, weights and jones
      3. weights is a sympy expression for generating weights
        from jones and weights.
  """
  # set up symbolic expressions
  jp00, jp01, jp10, jp11 = sympy.symbols(" ".join(JONES_P_ARGUMENTS), real=False)
  jq00, jq01, jq10, jq11 = sympy.symbols(" ".join(JONES_Q_ARGUMENTS), real=False)
  w00, w01, w10, w11 = sympy.symbols(" ".join(WEIGHT_ARGUMENTS), real=True)
  v00, v01, v10, v11 = sympy.symbols(" ".join(VIS_ARGUMENTS), real=False)

  # Jones matrices
  Jp = sympy.Matrix([[jp00, jp01], [jp10, jp11]])
  Jq = sympy.Matrix([[jq00, jq01], [jq10, jq11]])

  # Mueller matrix (row major form)
  Mpq = TensorProduct(Jp, Jq.conjugate())
  Mpqinv = TensorProduct(Jp.inv(), Jq.conjugate().inv())

  # inverse noise covariance
  Sinv = sympy.Matrix([[w00, 0, 0, 0], [0, w01, 0, 0], [0, 0, w10, 0], [0, 0, 0, w11]])
  S = Sinv.inv()

  # visibilities
  Vpq = sympy.Matrix([[v00], [v01], [v10], [v11]])

  # Full Stokes to corr operator
  # Is this the only difference between linear and circular pol?
  # What about paralactic angle rotation?

  if polarisations == "linear":
    T = sympy.Matrix(
      [[1.0, 1.0, 0, 0], [0, 0, 1.0, 1.0j], [0, 0, 1.0, -1.0j], [1.0, -1.0, 0, 0]]
    )
  elif polarisations == "circular":
    T = sympy.Matrix(
      [[1.0, 0, 0, 1.0], [0, 1.0, 1.0j, 0], [0, 1.0, -1.0j, 0], [1.0, 0, 0, -1.0]]
    )
  else:
    raise ValueError(f"{polarisations} not in {POLARISATION_TYPES}")

  Tinv = T.inv()

  # Full Stokes weights
  W = T.H * Mpq.H * Sinv * Mpq * T
  Winv = Tinv * Mpqinv * S * Mpqinv.H * Tinv.H

  # Full Stokes coherencies
  schema = ["I", "Q", "U", "V"]
  C = Winv * (T.H * (Mpq.H * (Sinv * Vpq)))
  # Only keep diagonal of weights
  W = W.diagonal().T  # diagonal() returns row vector

  C = sympy.simplify(C)
  W = sympy.simplify(W)

  id_jones = {
    jp00: 1 + 0j,
    jp01: 0 + 0j,
    jp10: 0 + 0j,
    jp11: 1 + 0j,
    jq00: 1 + 0j,
    jq01: 0 + 0j,
    jq10: 0 + 0j,
    jq11: 1 + 0j,
  }

  C_no_jones = sympy.simplify(C.subs(id_jones))
  W_no_jones = sympy.simplify(W.subs(id_jones))

  return schema, C, W, C_no_jones, W_no_jones


def subs_sympy(expr: sympy.Expr) -> str:
  """Simple string substitution on a sympy expression

  1. "I" -> "1j"
  2. "1.0*" -> ""
  3. "conjugate" -> "conj"
  """
  expr = re.sub(r"\bI\b", "1j", str(expr))
  expr = re.sub(r"\b1.0\*", "", str(expr))
  return re.sub(r"\bconjugate\b", "conj", expr)


def generate_expression(args: Namespace):
  with ExitStack() as stack:
    expr_path = stack.enter_context(
      importlib.resources.path(radiomesh, OUTPUT_FILENAME)
    )
    f = stack.enter_context(open(expr_path, "w"))

    f.write(PREAMBLE)
    conv_fns: Dict[Tuple[str, str, str, str], str] = {}

    for pol_type in POLARISATION_TYPES:
      stokes_schema, coh_jones, wgt_jones, coh_nojones, wgt_nojones = sympy_expressions(
        pol_type
      )
      assert coh_jones.shape == coh_nojones.shape == (len(stokes_schema), 1)
      assert wgt_jones.shape == wgt_nojones.shape == (len(stokes_schema), 1)

      for stokes, coh_jones in zip(stokes_schema, coh_jones):
        fn_name = f"{pol_type.upper()}_VIS_JONES_{stokes.upper()}"
        key = ("VIS", pol_type.upper(), "JONES", stokes.upper())
        conv_fns[key] = fn_name
        f.write(f"def {fn_name}({', '.join(VIS_FN_ARGUMENTS)}):\n")
        f.write(f"  return {subs_sympy(coh_jones)}\n")
        f.write("\n")

      for stokes, wgt_jones in zip(stokes_schema, wgt_jones):
        fn_name = f"{pol_type.upper()}_WEIGHT_JONES_{stokes.upper()}"
        key = ("WEIGHT", pol_type.upper(), "JONES", stokes.upper())
        conv_fns[key] = fn_name
        f.write(f"def {fn_name}({', '.join(WEIGHT_FN_ARGUMENTS)}):\n")
        f.write(f"  return ({subs_sympy(wgt_jones)}).real\n")
        f.write("\n")

      for stokes, coh_nojones in zip(stokes_schema, coh_nojones):
        fn_name = f"{pol_type.upper()}_VIS_NOJONES_{stokes.upper()}"
        key = ("VIS", pol_type.upper(), "NOJONES", stokes.upper())
        conv_fns[key] = fn_name
        f.write(f"def {fn_name}({', '.join(VIS_ARGUMENTS)}):\n")
        f.write(f"  return {subs_sympy(coh_nojones)}\n")
        f.write("\n")

      for stokes, wgt_nojones in zip(stokes_schema, wgt_nojones):
        fn_name = f"{pol_type.upper()}_WEIGHT_NOJONES_{stokes.upper()}"
        key = ("WEIGHT", pol_type.upper(), "NOJONES", stokes.upper())
        conv_fns[key] = fn_name
        f.write(f"def {fn_name}({', '.join(WEIGHT_ARGUMENTS)}):\n")
        f.write(f"  return ({subs_sympy(wgt_nojones)}).real\n")
        f.write("\n")

    f.write("CONVERT_FNS = {\n")
    for key, fn_name in conv_fns.items():
      f.write(f"  {key}: {fn_name},\n")
    f.write("}\n")
    f.write("\n")
